#!/usr/bin/env python3
# ! /usr/bin/python3
# -*- coding:UTF-8 -*-

RCBox = [0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36]
SBox = [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]
RSBox = [0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d]
Juzheng = [0x02, 0x03, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02] #Mixcolumn 矩阵
InvJuzheng = [0x0e,0x0b,0x0d,0x09,0x09,0x0e,0x0b,0x0d,0x0d,0x09,0x0e,0x0b,0x0b,0x0d,0x09,0x0e]

def fenzu128(num):
    m_ = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
    for i in range(3, -1, -1):
        for j in range(3, -1, -1): #hang
            temp = hex(num % 0x100)
            if len(temp) == 3: #如果出现0x* 只有一位16进制 加上0x0*
                temp = temp[:-1]+'0'+temp[-1:]
            num //= 0x100
            m_[j * 4 + i:j * 4 + i+1] = temp.split() #按列正确输入
                 #eval() hex->dec
    m_ = m_[:-1]
    return m_

def g(t,rd):
    t = t[1:] + t[:1]
    t = subBytes(t)
    temp = hex(eval(t[0]) ^ RCBox[rd])
    if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
        temp = temp[:-1] + '0' + temp[-1:]
    t = t[1:]
    t.insert(0,temp)
    return t

def roundkey(key):
    keys = []
    for rd in range(0,11):
        if rd == 0:
            keys.append(key)
        else:
            tempK = keys[-1]
            temp0,temp1,temp2,temp3 = [],[],[],[]
            tempbak = [temp0, temp1, temp2, temp3]
            for n in range(0,4):
                tempbak[n] = (tempK[n]+','+tempK[4+n]+','+tempK[8+n]+','+tempK[12+n]).split(',')
            [temp0, temp1, temp2, temp3] = tempbak
            #temp0 = tempK[:4]
            #temp1 = tempK[4:8]
            #temp2 = tempK[8:12]
            #temp3 = tempK[12:] #分为四组
            tg = g(temp3,rd) #g变换
            _m = []
            for i, j in zip(temp0, tg):
                temp = hex(eval(i) ^ eval(j))
                if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
                    temp = temp[:-1] + '0' + temp[-1:]
                _m.append(temp)
            tempbak = [temp1,temp2,temp3]
            for n in range(0,3):
                for i, j in zip(tempbak[n], _m[-4:]):
                    temp = hex(eval(i) ^ eval(j))
                    if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
                        temp = temp[:-1] + '0' + temp[-1:]
                    _m.append(temp)
            _m_ = []  #为了按行显示
            for i in range(0,4):
                for j in range(0,4):
                    _m_.append(_m[j*4+i])
            keys.append(_m_)
    return keys

def subBytes(m):
    m_ = []
    for n in m:
        n = n.replace('0x', '')
        temp = hex(SBox[eval('0x'+n[0])*0x10+eval('0x'+n[1])])
        if len(temp) == 3: #如果出现0x* 只有一位16进制 加上0x0*
            temp = temp[:-1]+'0'+temp[-1:]
        m_.append(temp)
    m = m_
    return m


def InvsubBytes(m):
    m_ = []
    for n in m:
        n = n.replace('0x', '')
        temp = hex(RSBox[eval('0x'+n[0])*0x10+eval('0x'+n[1])])
        if len(temp) == 3: #如果出现0x* 只有一位16进制 加上0x0*
            temp = temp[:-1]+'0'+temp[-1:]
        m_.append(temp)
    m = m_
    return m

def xunhuanzuoyi(lst,k): #循环左移
    return lst[k:] + lst[:k]

def shiftRows(m):
    m[4:8] = xunhuanzuoyi(m[4:8], 1)
    m[8:12] = xunhuanzuoyi(m[8:12], 2)
    m[12:] = xunhuanzuoyi(m[12:], 3)
    return m

def InvshiftRows(m):
    m[4:8] = xunhuanzuoyi(m[4:8], -1)
    m[8:12] = xunhuanzuoyi(m[8:12], -2)
    m[12:] = xunhuanzuoyi(m[12:], -3)
    return m

def chen(a,b,m):
    tempJuzhen = Juzheng[a*4:a*4+4]   #选取常规矩阵行
    tempM = []
    for i in range(0, 16, 4):
        temp = eval(m[b + i])
        #if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
        #   temp = temp[:-1] + '0' + temp[-1:]
        tempM.append(temp)
    sum = 0x0 #GF(2) 求和
    for i,j in zip(tempJuzhen,tempM):
        if i == 0x01:
            sum ^= j
        elif i == 0x02:
            j <<= 1 #左移一位检测最高位
            if j >= 0x100: #最高位为1
                j &= 0x0ff #最高位舍去
                j ^= 0x1b
            sum ^= j
        else:   #0x03情况
            tempj = j
            j <<= 1
            if j >= 0x100:
                j &= 0x0ff
                j ^= 0x1b
            j ^= tempj
            sum ^= j
    sum = hex(sum)
    if len(sum) == 3:
        sum = sum[:-1] + '0' + sum[-1:]
    return sum

def mixColumns(m):
    _m = []
    for a in range(0,4):
        for b in range(0,4):
           _m.append(chen(a,b,m))
    return _m

def Invchen(a,b,m):
    tempJuzhen = InvJuzheng[a * 4:a * 4 + 4]
    tempM = []
    for i in range(0, 16, 4):
        temp = eval(m[b + i])
        #if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
        #   temp = temp[:-1] + '0' + temp[-1:]
        tempM.append(temp)
    sum = 0x0 #GF(2) 求和
    for i,j in zip(tempJuzhen,tempM):
        if i == 0x01:
            sum ^= j
        else:
            yushu = i % 2
            if yushu == 1:
                sum ^= j
            while i != 0x01:
                s = i//2
                if s % 2 == 1:
                    j = j << 1
                    if j >= 0x100:
                        j &= 0x0ff
                        j ^= 0x1b
                        sum ^= j
                    else:
                        sum ^= j
                else: #就算是为0，当前也要变，为下一步做准备
                    j = j << 1
                    if j >= 0x100:
                        j &= 0x0ff
                        j ^= 0x1b
                i //= 2
    sum = hex(sum)
    if len(sum) == 3:
        sum = sum[:-1] + '0' + sum[-1:]
    return sum

def InvmixColumns(m):
    _m = []
    for a in range(0,4):
        for b in range(0,4):
           _m.append(Invchen(a,b,m))
    return _m

def addRoundKey(m,rkey):
    _m = []
    for i,j in zip(m,rkey):
        temp = hex(eval(i) ^ eval(j))
        if len(temp) == 3:  # 如果出现0x* 只有一位16进制 加上0x0*
            temp = temp[:-1] + '0' + temp[-1:]
        _m.append(temp)
    return _m

def jiemi(m,key):
    keys = roundkey(key)
    print(keys)
    m = addRoundKey(m,keys[10])
    for n in range(9,-1,-1):
        if n == 0:
            m = InvshiftRows(m)
            m = InvsubBytes(m)
            m = addRoundKey(m, keys[n])
        else:
            m = InvshiftRows(m)
            m = InvsubBytes(m)
            m = addRoundKey(m, keys[n])
            m = InvmixColumns(m)
    return m

#m = input('Please input plaintext:')
#key = input('Please input key:')
m = 0x3243f6a8885a308d313198a2e0370734
key = 0x2b7e151628aed2a6abf7158809cf4f3c
c = 0x3925841d02dc09fbdc118597196a0b32

#对明文进行分组 hex
c = fenzu128(c)
key = fenzu128(key)
print(c,key)
nm = jiemi(c,key)
print (nm)
m = fenzu128(m)
if nm == m:
    print('成功！')